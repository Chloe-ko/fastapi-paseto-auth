{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FastAPI PASETO Auth Documentation : https://chloe-ko.github.io/fastapi-paseto-auth Source Code : https://github.com/Chloe-ko/fastapi-paseto-auth FastAPI extension that provides PASETO ( P lastform- A gnostic SE curity TO kens) Auth support\\ PASETO are a simpler, yet more secure alternative to JWTs. If you were familiar with flask-jwt-extended or fastapi-jwt-auth this extension suitable for you, as this is forked from fastapi-jwt-auth which in turn used flask-jwt-extended as motivation Features \u00b6 Access tokens and refresh tokens Freshness Tokens Revoking Tokens Support for adding custom claims to Tokens Built-in Base64 Encoding of Tokens Custom token types Installation \u00b6 The easiest way to start working with this extension with pip pip install fastapi-paseto-auth Roadmap \u00b6 Support for WebSocket authorization FAQ \u00b6 Where's support for tokens in cookies? \\ I mostly forked fastapi-jwt-auth because I needed a library to use for authentication using PASETO tokens in my private FastAPI Application. Which is why I only kept the functionality that I personally required.\\ Personally, I'm not a fan of saving data in cookies, and cookie support made up a big part of the code which just didn't make sense for me to bother adapting.\\ Hence, I likely will not be implementing support for storing PASETO tokens in cookies unless there is a considerable amount of people wanting it.\\ However, I will gladly accept PRs implementing tokens in cookies if someone else wants to implement it. License \u00b6 This project is licensed under the terms of the MIT license.","title":"About"},{"location":"#features","text":"Access tokens and refresh tokens Freshness Tokens Revoking Tokens Support for adding custom claims to Tokens Built-in Base64 Encoding of Tokens Custom token types","title":"Features"},{"location":"#installation","text":"The easiest way to start working with this extension with pip pip install fastapi-paseto-auth","title":"Installation"},{"location":"#roadmap","text":"Support for WebSocket authorization","title":"Roadmap"},{"location":"#faq","text":"Where's support for tokens in cookies? \\ I mostly forked fastapi-jwt-auth because I needed a library to use for authentication using PASETO tokens in my private FastAPI Application. Which is why I only kept the functionality that I personally required.\\ Personally, I'm not a fan of saving data in cookies, and cookie support made up a big part of the code which just didn't make sense for me to bother adapting.\\ Hence, I likely will not be implementing support for storing PASETO tokens in cookies unless there is a considerable amount of people wanting it.\\ However, I will gladly accept PRs implementing tokens in cookies if someone else wants to implement it.","title":"FAQ"},{"location":"#license","text":"This project is licensed under the terms of the MIT license.","title":"License"},{"location":"api-doc/","text":"In here you will find the API for everything exposed in this extension. Configuring FastAPI PASETO Auth \u00b6 load_config (callback): This decorator sets the callback function to overwrite state on AuthPASETO class so when you initialize an instance in dependency injection default value will be overwritten. The callback must be a function that returns a list of tuple or pydantic object. token_in_denylist_loader (callback): This decorator sets the callback function that will be called when a protected endpoint is accessed and will check if the PASETO has been revoked. By default, this callback is not used. The callback must be a function that takes `one` argument, which is the decoded PASETO (python dictionary), and returns `True` if the token has been revoked, or `False` otherwise. \u00b6 Protected Endpoint \u00b6 paseto_required (optional: bool = False, fresh: bool = False, refresh_token: bool = False, type: str = access, base64_encoded: bool = False): If you call this function, it will ensure that the requester has a valid access token before executing the code below your router. Depending on set options, it might not raise an exception even if the check fails.* * Parameters: **optional**: Defines whether the check should continue even if no PASETO is found.\\ (An exception will still always be raised if an invalid one is found.) **fresh**: If set to True, requires any PASETO found to be a fresh access token. **refresh_token**: If set to True, checks for a refresh token instead of an access token. **type**: If set to a string, this gets checked against the type of the token provided. Used for custom types other than access or refresh tokens. **base64_encoded**: Whether the token to check is base64 encoded. * Returns: None Utilities \u00b6 create_access_token (subject, fresh=False, purpose=None, headers=None, expires_time=None, audience=None, user_claims={}, base64_encode: bool = False): *Create a new access token.* * Parameters: **subject**: Identifier for who this token is for example id or username from database **fresh**: Identify if token is fresh or non-fresh **purpose**: Purpose for the PASETO **headers**: Valid dict for specifying additional headers in PASETO header section **expires_time**: Set the duration of the PASETO **audience**: Expected audience in the PASETO **user_claims**: Custom claims to include in this token. This data must be dictionary **base64_encode**: If true the created token will be base64 encoded. This is useful for if you need to pass the token somewhere where special characters might cause issues. * Returns: An encoded access token create_refresh_token (subject, purpose=None, headers=None, expires_time=None, audience=None, user_claims={}, base64_encode: bool = False): *Creates a new refresh token.* * Parameters: **subject**: Identifier for who this token is for example id or username from database **purpose**: Purpose for the PASETO **headers**: Valid dict for specifying additional headers in PASETO header section **expires_time**: Set the duration of the PASETO **audience**: Expected audience in the PASETO **user_claims**: Custom claims to include in this token. This data must be dictionary **base64_encode**: If true the created token will be base64 encoded. This is useful for if you need to pass the token somewhere where special characters might cause issues. * Returns: An encoded refresh token create_token (subject, type, purpose=None, headers=None, expires_time=None, audience=None, user_claims={}, base64_encode: bool = False): *Creates a new refresh token.* * Parameters: **subject**: Identifier for who this token is for example id or username from database **type**: Type of the token to be created **purpose**: Purpose for the PASETO **headers**: Valid dict for specifying additional headers in PASETO header section **expires_time**: Set the duration of the PASETO **audience**: Expected audience in the PASETO **user_claims**: Custom claims to include in this token. This data must be dictionary **base64_encode**: If true the created token will be base64 encoded. This is useful for if you need to pass the token somewhere where special characters might cause issues. * Returns: An encoded refresh token get_token_payload (): *This will return the python dictionary which has all of the claims of the PASETO that is accessing the endpoint. If no PASETO is currently present, return `None` instead.* * Parameters: None * Returns: Dictionary that contains the claims of PASETO get_jti (): *Returns the JTI (unique identifier) of an the PASETO that is accessing the endpoint* * Parameters: None * Returns: String of JTI get_subject (): *This will return the subject of the PASETO that is accessing the endpoint. If no PASETO is present, `None` is returned instead.*","title":"API Documentation"},{"location":"api-doc/#configuring-fastapi-paseto-auth","text":"load_config (callback): This decorator sets the callback function to overwrite state on AuthPASETO class so when you initialize an instance in dependency injection default value will be overwritten. The callback must be a function that returns a list of tuple or pydantic object. token_in_denylist_loader (callback): This decorator sets the callback function that will be called when a protected endpoint is accessed and will check if the PASETO has been revoked. By default, this callback is not used. The callback must be a function that takes `one` argument, which is the decoded PASETO (python dictionary), and returns `True` if the token has been revoked, or `False` otherwise.","title":"Configuring FastAPI PASETO Auth"},{"location":"api-doc/#_1","text":"","title":""},{"location":"api-doc/#protected-endpoint","text":"paseto_required (optional: bool = False, fresh: bool = False, refresh_token: bool = False, type: str = access, base64_encoded: bool = False): If you call this function, it will ensure that the requester has a valid access token before executing the code below your router. Depending on set options, it might not raise an exception even if the check fails.* * Parameters: **optional**: Defines whether the check should continue even if no PASETO is found.\\ (An exception will still always be raised if an invalid one is found.) **fresh**: If set to True, requires any PASETO found to be a fresh access token. **refresh_token**: If set to True, checks for a refresh token instead of an access token. **type**: If set to a string, this gets checked against the type of the token provided. Used for custom types other than access or refresh tokens. **base64_encoded**: Whether the token to check is base64 encoded. * Returns: None","title":"Protected Endpoint"},{"location":"api-doc/#utilities","text":"create_access_token (subject, fresh=False, purpose=None, headers=None, expires_time=None, audience=None, user_claims={}, base64_encode: bool = False): *Create a new access token.* * Parameters: **subject**: Identifier for who this token is for example id or username from database **fresh**: Identify if token is fresh or non-fresh **purpose**: Purpose for the PASETO **headers**: Valid dict for specifying additional headers in PASETO header section **expires_time**: Set the duration of the PASETO **audience**: Expected audience in the PASETO **user_claims**: Custom claims to include in this token. This data must be dictionary **base64_encode**: If true the created token will be base64 encoded. This is useful for if you need to pass the token somewhere where special characters might cause issues. * Returns: An encoded access token create_refresh_token (subject, purpose=None, headers=None, expires_time=None, audience=None, user_claims={}, base64_encode: bool = False): *Creates a new refresh token.* * Parameters: **subject**: Identifier for who this token is for example id or username from database **purpose**: Purpose for the PASETO **headers**: Valid dict for specifying additional headers in PASETO header section **expires_time**: Set the duration of the PASETO **audience**: Expected audience in the PASETO **user_claims**: Custom claims to include in this token. This data must be dictionary **base64_encode**: If true the created token will be base64 encoded. This is useful for if you need to pass the token somewhere where special characters might cause issues. * Returns: An encoded refresh token create_token (subject, type, purpose=None, headers=None, expires_time=None, audience=None, user_claims={}, base64_encode: bool = False): *Creates a new refresh token.* * Parameters: **subject**: Identifier for who this token is for example id or username from database **type**: Type of the token to be created **purpose**: Purpose for the PASETO **headers**: Valid dict for specifying additional headers in PASETO header section **expires_time**: Set the duration of the PASETO **audience**: Expected audience in the PASETO **user_claims**: Custom claims to include in this token. This data must be dictionary **base64_encode**: If true the created token will be base64 encoded. This is useful for if you need to pass the token somewhere where special characters might cause issues. * Returns: An encoded refresh token get_token_payload (): *This will return the python dictionary which has all of the claims of the PASETO that is accessing the endpoint. If no PASETO is currently present, return `None` instead.* * Parameters: None * Returns: Dictionary that contains the claims of PASETO get_jti (): *Returns the JTI (unique identifier) of an the PASETO that is accessing the endpoint* * Parameters: None * Returns: String of JTI get_subject (): *This will return the subject of the PASETO that is accessing the endpoint. If no PASETO is present, `None` is returned instead.*","title":"Utilities"},{"location":"contributing/","text":"Sharing feedback \u00b6 This project is still relatively new and probably has flaws, both in terms of internal usability as well as code quality.\\ I have tried my best to however make sure that it is as secure as it can be.\\ I also do not yet have a complete understanding of the project, especially the CI/CD and tests. If you find something I missed to adjust, please feel free to let me know. If you have suggestions for improvements or want to help, feel free to open an issue or create a PR with your modifications. Developing \u00b6 If you already cloned the repository and you know that you need to deep dive in the code, here are some guidelines to set up your environment. This project uses VS Code Development containers. With the Remote - Containers extension installed in VSCode, and Docker installed on your device, VSCode should automatically prompt you about having found a development container configuration file and offer you to open the project in the container. If not, you can always press F1 and manually click \"Remote-Containers: Open Folder in Container\" and select the source of this repo that contains the .devcontainer folder. Any development dependencies will be automatically installed. You might need to select the correct python interpreter after opening it in container, as VS Code defaults to using the system-wide interpreter, rather than the one set up by Pipenv. Flit \u00b6 You can use flit to install the development dependencies that tests require to run: $ flit install --deps develop --symlink It will install all the dependencies and your local FastAPI JWT Auth in your local environment. Using your local FastAPI PASETO Auth If you create a Python file that imports and uses FastAPI PASETO Auth, and run it with the Python from your local environment, it will use your local FastAPI PASETO Auth source code. This is thanks to the --symlink flag in the flit command shown above. That way, you don't have to \"install\" your local version to be able to test every change. Docs \u00b6 The documentation uses MkDocs . All the documentation is in Markdown format in the directory ./docs . Many of the sections in the User Guide have blocks of code. In fact, those blocks of code are not written inside the Markdown, they are Python files in the ./examples/ directory. And those Python files are included/injected in the documentation when generating the site. Docs for tests \u00b6 Most of the tests actually run against the example source files in the documentation. This helps making sure that: The documentation is up to date. The documentation examples can be run as is. Most of the features are covered by the documentation, ensured by test coverage. During local development, there is a script that builds the site and checks for any changes, live-reloading: $ bash scripts/docs-live.sh It will serve the documentation on http://0.0.0.0:5000 . That way, you can edit the documentation/source files and see the changes live. Tests \u00b6 There is a script that you can run locally to test all the code and generate coverage reports in HTML: $ bash scripts/tests.sh This command generates a directory ./htmlcov/ , if you open the file ./htmlcov/index.html in your browser, you can explore interactively the regions of code that are covered by the tests, and notice if there is any region missing.","title":"Development - Contributing"},{"location":"contributing/#sharing-feedback","text":"This project is still relatively new and probably has flaws, both in terms of internal usability as well as code quality.\\ I have tried my best to however make sure that it is as secure as it can be.\\ I also do not yet have a complete understanding of the project, especially the CI/CD and tests. If you find something I missed to adjust, please feel free to let me know. If you have suggestions for improvements or want to help, feel free to open an issue or create a PR with your modifications.","title":"Sharing feedback"},{"location":"contributing/#developing","text":"If you already cloned the repository and you know that you need to deep dive in the code, here are some guidelines to set up your environment. This project uses VS Code Development containers. With the Remote - Containers extension installed in VSCode, and Docker installed on your device, VSCode should automatically prompt you about having found a development container configuration file and offer you to open the project in the container. If not, you can always press F1 and manually click \"Remote-Containers: Open Folder in Container\" and select the source of this repo that contains the .devcontainer folder. Any development dependencies will be automatically installed. You might need to select the correct python interpreter after opening it in container, as VS Code defaults to using the system-wide interpreter, rather than the one set up by Pipenv.","title":"Developing"},{"location":"contributing/#flit","text":"You can use flit to install the development dependencies that tests require to run: $ flit install --deps develop --symlink It will install all the dependencies and your local FastAPI JWT Auth in your local environment. Using your local FastAPI PASETO Auth If you create a Python file that imports and uses FastAPI PASETO Auth, and run it with the Python from your local environment, it will use your local FastAPI PASETO Auth source code. This is thanks to the --symlink flag in the flit command shown above. That way, you don't have to \"install\" your local version to be able to test every change.","title":"Flit"},{"location":"contributing/#docs","text":"The documentation uses MkDocs . All the documentation is in Markdown format in the directory ./docs . Many of the sections in the User Guide have blocks of code. In fact, those blocks of code are not written inside the Markdown, they are Python files in the ./examples/ directory. And those Python files are included/injected in the documentation when generating the site.","title":"Docs"},{"location":"contributing/#docs-for-tests","text":"Most of the tests actually run against the example source files in the documentation. This helps making sure that: The documentation is up to date. The documentation examples can be run as is. Most of the features are covered by the documentation, ensured by test coverage. During local development, there is a script that builds the site and checks for any changes, live-reloading: $ bash scripts/docs-live.sh It will serve the documentation on http://0.0.0.0:5000 . That way, you can edit the documentation/source files and see the changes live.","title":"Docs for tests"},{"location":"contributing/#tests","text":"There is a script that you can run locally to test all the code and generate coverage reports in HTML: $ bash scripts/tests.sh This command generates a directory ./htmlcov/ , if you open the file ./htmlcov/index.html in your browser, you can explore interactively the regions of code that are covered by the tests, and notice if there is any region missing.","title":"Tests"},{"location":"release-notes/","text":"0.6.0 \u00b6 Add more per-request overrides to give more dynamic possibilities for ways to pass the token to AuthPASETO 0.5.5 \u00b6 Add request json as possible token location 0.5.4 \u00b6 Fix incorrect way to get seconds from datetime.timedelta instance 0.5.3 \u00b6 Add ability to base64 encode and decode tokens 0.5.2 \u00b6 Implement custom token types 0.5.1 \u00b6 Update documentation and tests, mostly a meta update 0.5.0 \u00b6 Initial release.","title":"Release Notes"},{"location":"release-notes/#060","text":"Add more per-request overrides to give more dynamic possibilities for ways to pass the token to AuthPASETO","title":"0.6.0"},{"location":"release-notes/#055","text":"Add request json as possible token location","title":"0.5.5"},{"location":"release-notes/#054","text":"Fix incorrect way to get seconds from datetime.timedelta instance","title":"0.5.4"},{"location":"release-notes/#053","text":"Add ability to base64 encode and decode tokens","title":"0.5.3"},{"location":"release-notes/#052","text":"Implement custom token types","title":"0.5.2"},{"location":"release-notes/#051","text":"Update documentation and tests, mostly a meta update","title":"0.5.1"},{"location":"release-notes/#050","text":"Initial release.","title":"0.5.0"},{"location":"advanced-usage/additional-claims/","text":"You may want to store additional information in the access token or refresh token that you can later access in the protected views. This can be done easily by passion additional information as a dictionary to the parameter user_claims in the functions create_access_token() or create_refresh_token() , and the data can be accessed later in a protected endpoint with the get_token_payload() function. Storing data in the tokens can be good for performance.\\ If you store data in the tokens, you won't need to look it up from disk/DB next time you need it in a protected endpoint.\\ However, you might need to take care of what data you put in the tokens. Note : When using the \"public\" purpose of PASETO tokens, the data in the token will merely be signed, but not encrypted. This means anyone with access to the token can freely read it's contents.\\ Hence, do not store sensitive information in public tokens. Whether you trust local (encrypted) PASETO tokens to keep sensitive information is up to your own discretion. from fastapi import FastAPI , HTTPException , Depends , Request from fastapi.responses import JSONResponse from fastapi_paseto_auth import AuthPASETO from fastapi_paseto_auth.exceptions import AuthPASETOException from pydantic import BaseModel app = FastAPI () class User ( BaseModel ): username : str password : str class Settings ( BaseModel ): authpaseto_secret_key : str = \"secret\" @AuthPASETO . load_config def get_config (): return Settings () @app . exception_handler ( AuthPASETOException ) def authpaseto_exception_handler ( request : Request , exc : AuthPASETOException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message }) @app . post ( \"/login\" ) def login ( user : User , Authorize : AuthPASETO = Depends ()): if user . username != \"test\" or user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) # You can be passing custom claim to argument user_claims # in function create_access_token() or create_refresh_token() extra_claims = { \"foo\" : [ \"fiz\" , \"baz\" ]} access_token = Authorize . create_access_token ( subject = user . username , user_claims = extra_claims ) return { \"access_token\" : access_token } # In protected route, get the claims you added to the paseto with the # get_token_payload() method @app . get ( \"/claims\" ) def user ( Authorize : AuthPASETO = Depends ()): Authorize . paseto_required () foo_claims = Authorize . get_token_payload ()[ \"foo\" ] return { \"foo\" : foo_claims }","title":"Additional claims"},{"location":"advanced-usage/bigger-app/","text":"Because fastapi-paseto-auth configures your setting via a class state that applies across all instances of the class, you only need to make sure to call load_config (callback) before declaring any endpoint. Thanks to FastAPI when you make an endpoint from APIRouter it will actually work as if everything was the same single app. So you only need to define load_config (callback) where your FastAPI instance is created or you can import it where you include all the routers. An example file structure \u00b6 Let's say you have a file structure like this: . \u251c\u2500\u2500 multiple_files \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 app.py \u2502 \u2514\u2500\u2500 routers \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 items.py \u2502 \u2514\u2500\u2500 users.py Here an example of app.py from fastapi import FastAPI , Request from fastapi.responses import JSONResponse from fastapi_paseto_auth import AuthPASETO from fastapi_paseto_auth.exceptions import AuthPASETOException from routers import users , items from pydantic import BaseModel app = FastAPI () class Settings ( BaseModel ): authpaseto_secret_key : str = \"secret\" @AuthPASETO . load_config def get_config (): return Settings () @app . exception_handler ( AuthPASETOException ) def authpaseto_exception_handler ( request : Request , exc : AuthPASETOException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message }) app . include_router ( users . router , tags = [ \"users\" ]) app . include_router ( items . router , tags = [ \"items\" ]) Here an example of users.py from fastapi import APIRouter , Depends , HTTPException from fastapi_paseto_auth import AuthPASETO from pydantic import BaseModel class User ( BaseModel ): username : str password : str router = APIRouter () @router . post ( \"/login\" ) def login ( user : User , Authorize : AuthPASETO = Depends ()): if user . username != \"test\" or user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) access_token = Authorize . create_access_token ( subject = user . username ) return { \"access_token\" : access_token } Here an example of items.py from fastapi import APIRouter , Depends from fastapi_paseto_auth import AuthPASETO router = APIRouter () @router . get ( \"/items\" ) def items ( Authorize : AuthPASETO = Depends ()): Authorize . paseto_required () items = [ \"item1\" , \"item2\" , \"item3\" ] return { \"items\" : items }","title":"Bigger Applications"},{"location":"advanced-usage/bigger-app/#an-example-file-structure","text":"Let's say you have a file structure like this: . \u251c\u2500\u2500 multiple_files \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 app.py \u2502 \u2514\u2500\u2500 routers \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 items.py \u2502 \u2514\u2500\u2500 users.py Here an example of app.py from fastapi import FastAPI , Request from fastapi.responses import JSONResponse from fastapi_paseto_auth import AuthPASETO from fastapi_paseto_auth.exceptions import AuthPASETOException from routers import users , items from pydantic import BaseModel app = FastAPI () class Settings ( BaseModel ): authpaseto_secret_key : str = \"secret\" @AuthPASETO . load_config def get_config (): return Settings () @app . exception_handler ( AuthPASETOException ) def authpaseto_exception_handler ( request : Request , exc : AuthPASETOException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message }) app . include_router ( users . router , tags = [ \"users\" ]) app . include_router ( items . router , tags = [ \"items\" ]) Here an example of users.py from fastapi import APIRouter , Depends , HTTPException from fastapi_paseto_auth import AuthPASETO from pydantic import BaseModel class User ( BaseModel ): username : str password : str router = APIRouter () @router . post ( \"/login\" ) def login ( user : User , Authorize : AuthPASETO = Depends ()): if user . username != \"test\" or user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) access_token = Authorize . create_access_token ( subject = user . username ) return { \"access_token\" : access_token } Here an example of items.py from fastapi import APIRouter , Depends from fastapi_paseto_auth import AuthPASETO router = APIRouter () @router . get ( \"/items\" ) def items ( Authorize : AuthPASETO = Depends ()): Authorize . paseto_required () items = [ \"item1\" , \"item2\" , \"item3\" ] return { \"items\" : items }","title":"An example file structure"},{"location":"advanced-usage/expiry_time/","text":"You can also change the expiry time for a token via parameter expires_time in the create_access_token() or create_refresh_token() function. This takes a datetime.timedelta , datetime.datetime , integer , or even boolean and overrides the authpaseto_access_token_expires and authpaseto_refresh_token_expires settings. This can be useful if you have different use cases for different tokens. @app . post ( '/create-dynamic-token' ) def create_dynamic_token ( Authorize : AuthPASETO = Depends ()): expires = datetime . timedelta ( days = 1 ) token = Authorize . create_access_token ( subject = \"test\" , expires_time = expires ) return { \"token\" : token } You can even disable expiration by setting expires_time to False : @app . post ( '/create-token-disable' ) def create_dynamic_token ( Authorize : AuthPASETO = Depends ()): token = Authorize . create_access_token ( subject = \"test\" , expires_time = False ) return { \"token\" : token }","title":"Token Expire Time"},{"location":"advanced-usage/generate-docs/","text":"It feels incomplete if there is no documentation because fastapi-paseto-auth uses starlette requests directly to get headers, you must manually generate the documentation. Thanks to FastAPI you can generate doc easily via Extending OpenAPI . Here is an example to generate the doc: from fastapi import FastAPI , Request , Depends , HTTPException from fastapi.responses import JSONResponse from fastapi.openapi.utils import get_openapi from fastapi_paseto_auth import AuthPASETO from fastapi_paseto_auth.exceptions import AuthPASETOException from pydantic import BaseModel app = FastAPI () class User ( BaseModel ): username : str password : str class Settings ( BaseModel ): authpaseto_secret_key : str = \"secret\" @AuthPASETO . load_config def get_config (): return Settings () @app . exception_handler ( AuthPASETOException ) def authpaseto_exception_handler ( request : Request , exc : AuthPASETOException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message }) @app . post ( \"/login\" ) def login ( user : User , Authorize : AuthPASETO = Depends ()): if user . username != \"test\" or user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) access_token = Authorize . create_access_token ( subject = user . username ) return { \"access_token\" : access_token } @app . get ( \"/protected\" , operation_id = \"authorize\" ) def protected ( Authorize : AuthPASETO = Depends ()): Authorize . paseto_required () current_user = Authorize . get_subject () return { \"user\" : current_user } def custom_openapi (): if app . openapi_schema : return app . openapi_schema openapi_schema = get_openapi ( title = \"Custom title\" , version = \"2.5.0\" , description = \"This is a very custom OpenAPI schema\" , routes = app . routes , ) # Custom documentation fastapi-paseto-auth headers = { \"name\" : \"Authorization\" , \"in\" : \"header\" , \"required\" : True , \"schema\" : { \"title\" : \"Authorization\" , \"type\" : \"string\" }, } # Get routes from index 4 because before that fastapi define router for /openapi.json, /redoc, /docs, etc # Get all router where operation_id is authorize router_authorize = [ route for route in app . routes [ 4 :] if route . operation_id == \"authorize\" ] for route in router_authorize : method = list ( route . methods )[ 0 ] . lower () try : # If the router has another parameter openapi_schema [ \"paths\" ][ route . path ][ method ][ \"parameters\" ] . append ( headers ) except Exception : # If the router doesn't have a parameter openapi_schema [ \"paths\" ][ route . path ][ method ] . update ( { \"parameters\" : [ headers ]} ) app . openapi_schema = openapi_schema return app . openapi_schema app . openapi = custom_openapi","title":"Generate Documentation"},{"location":"advanced-usage/purpose/","text":"You can specify which purpose you would like to use for a PASETO by using the purpose parameter in create_access_token() or create_refresh_token() . Please read up on PASETO tokens to find out which is the best purpose for your use case, but to put it short: Local purpose means the token will be encrypted using symmetric encryption. Data in the token will not be accessible to people that get the token without also knowing your secret key.\\ This is useful if the token is used in an environment where every party that needs access to the token's contents is a secure environment under your control that you can share the secret key with. Public purpose means the token will not be encrypted, and instead will only be signed using your private key. The data in the key will be visible to everyone that gets ahold of the key , and you should not put any confidential or sensitive data into public keys. The key can then be validated using your public key, which is safe to share with not-trusted parties. from fastapi import FastAPI , HTTPException , Depends , Request from fastapi.responses import JSONResponse from fastapi_paseto_auth import AuthPASETO from fastapi_paseto_auth.exceptions import AuthPASETOException from pydantic import BaseModel app = FastAPI () class User ( BaseModel ): username : str password : str class Settings ( BaseModel ): authpaseto_secret_key : str = \"secret\" # Private and public keys are required if you want to use public purpose authentication authpaseto_private_key : str = \"\"\" -----BEGIN PRIVATE KEY----- MC4CAQAwBQYDK2VwBCIEIL7pfyWYtZD7fDPDm+W0kWbNo/AdbRrDjjxMOgy2EL1N -----END PRIVATE KEY----- \"\"\" authpaset_public_key : str = \"\"\" -----BEGIN PUBLIC KEY----- MCowBQYDK2VwAyEAc4ZDHPLZ6eGU3yL4ApPpQUq4cQUA900NY1csJIcwAxY= -----END PUBLIC KEY----- \"\"\" @AuthPASETO . load_config def get_config (): return Settings () @app . exception_handler ( AuthPASETOException ) def authpaseto_exception_handler ( request : Request , exc : AuthPASETOException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message }) @app . post ( \"/login\" ) def login ( user : User , Authorize : AuthPASETO = Depends ()): if user . username != \"test\" or user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) # You can define different purpose when creating a token access_token = Authorize . create_access_token ( subject = user . username , purpose = \"local\" ) refresh_token = Authorize . create_refresh_token ( subject = user . username , purpose = \"public\" ) return { \"access_token\" : access_token , \"refresh_token\" : refresh_token } # In a protected route, you don't need to worry about what type of key you are receiving # because it will automatically be detected by the library. @app . post ( \"/refresh\" ) def refresh ( Authorize : AuthPASETO = Depends ()): Authorize . paseto_required ( refresh_token = True ) current_user = Authorize . get_subject () new_access_token = Authorize . create_access_token ( subject = current_user ) return { \"access_token\" : new_access_token } @app . get ( \"/protected\" ) def protected ( Authorize : AuthPASETO = Depends ()): Authorize . paseto_required () current_user = Authorize . get_subject () return { \"user\" : current_user }","title":"Token Purpose"},{"location":"configuration/denylist/","text":"authpaseto_denylist_enabled Enable/disable token revoking. Defaults to False authpaseto_denylist_token_checks What token types to check against the denylist. The options are access or refresh . You can pass in a sequence to check more than one type. Defaults to {'access', 'refresh'} . Only used if deny listing is enabled.","title":"Denylist Options"},{"location":"configuration/general/","text":"authpaseto_secret_key The secret key needed for symmetric based signing algorithms, such as HS* . Defaults to None authpaseto_public_key The public key needed for asymmetric based signing algorithms, such as RS* or EC* . PEM format expected. Defaults to None authpaseto_private_key The private key needed for asymmetric based signing algorithms, such as RS* or EC* . PEM format expected. Defaults to None authpaseto_purpose Which purpose to use for the tokens. Options are public for asymmetric, local for symmetric. Defaults to local authpaseto_decode_leeway Define the leeway part of the expiration time definition, which means you can validate an expiration time which is in the past but not very far. Defaults to 0 authpaseto_encode_issuer Define the issuer to set the issuer in PASETO claims, only access token have issuer claim. Defaults to None authpaseto_decode_issuer Define the issuer to check the issuer in PASETO claims, only access token have issuer claim. Defaults to None authpaseto_decode_audience The audience or list of audiences you expect in a PASETO when decoding it. Defaults to None authpaseto_access_token_expires How long an access token should live before it expires. This takes value integer (seconds) or datetime.timedelta , and defaults to 15 minutes . Can be set to False to disable expiration. authpaseto_refresh_token_expires How long an refresh token should live before it expires. This takes value integer (seconds) or datetime.timedelta , and defaults to 30 days . Can be set to False to disable expiration.","title":"General Options"},{"location":"configuration/headers/","text":"These are only applicable if authpaseto_token_location is use headers. authpaseto_header_name What header to look for the PASETO in a request. Defaults to Authorization authpaseto_header_type What type of header the PASETO is in. Defaults to Bearer . This can be an empty string, in which case the header contains only the PASETO instead like HeaderName: Bearer <PASETO>","title":"Headers Options"},{"location":"usage/basic/","text":"Create a file basic.py : from fastapi import FastAPI , HTTPException , Depends , Request from fastapi.responses import JSONResponse from fastapi_paseto_auth import AuthPASETO from fastapi_paseto_auth.exceptions import AuthPASETOException from pydantic import BaseModel app = FastAPI () class User ( BaseModel ): username : str password : str # in production you can use Settings management # from pydantic to get secret key from .env class Settings ( BaseModel ): authoaseto_secret_key : str = \"secret\" # callback to get your configuration @AuthPASETO . load_config def get_config (): return Settings () # exception handler for authpaseto # in production, you can tweak performance using orjson response @app . exception_handler ( AuthPASETOException ) def authpaseto_exception_handler ( request : Request , exc : AuthPASETOException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message }) # provide a method to create access tokens. The create_access_token() # function is used to actually generate the token to use authorization # later in endpoint protected @app . post ( \"/login\" ) def login ( user : User , Authorize : AuthPASETO = Depends ()): if user . username != \"test\" or user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) # subject identifier for who this token is for example id or username from database access_token = Authorize . create_access_token ( subject = user . username ) return { \"access_token\" : access_token } # protect endpoint with function paseto_required(), which requires # a valid access token in the request headers to access. @app . get ( \"/user\" ) def user ( Authorize : AuthPASETO = Depends ()): Authorize . paseto_required () current_user = Authorize . get_subject () return { \"user\" : current_user } Run the server with: $ uvicorn basic:app --host 0 .0.0.0 INFO: Started server process [ 9859 ] INFO: Waiting for application startup. INFO: Application startup complete. INFO: Uvicorn running on http://0.0.0.0:8000 ( Press CTRL+C to quit ) To access a paseto_required protected url, all we have to do is send the PASETO with the request. By default, this is done with an authorization header that looks like: Authorization: Bearer <access_token> We can see this in action using curl : $ curl http://localhost:8000/user { \"detail\" : \"Missing Authorization Header\" } $ curl -H \"Content-Type: application/json\" -X POST \\ -d '{\"username\":\"test\",\"password\":\"test\"}' http://localhost:8000/login { \"access_token\" : \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ0ZXN0IiwiaWF0IjoxNjAzNjkyMjYxLCJuYmYiOjE2MDM2OTIyNjEsImp0aSI6IjZiMjZkZTkwLThhMDYtNDEzMy04MzZiLWI5ODJkZmI3ZjNmZSIsImV4cCI6MTYwMzY5MzE2MSwidHlwZSI6ImFjY2VzcyIsImZyZXNoIjpmYWxzZX0.ro5JMHEVuGOq2YsENkZigSpqMf5cmmgPP8odZfxrzJA\" } $ export TOKEN = eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ0ZXN0IiwiaWF0IjoxNjAzNjkyMjYxLCJuYmYiOjE2MDM2OTIyNjEsImp0aSI6IjZiMjZkZTkwLThhMDYtNDEzMy04MzZiLWI5ODJkZmI3ZjNmZSIsImV4cCI6MTYwMzY5MzE2MSwidHlwZSI6ImFjY2VzcyIsImZyZXNoIjpmYWxzZX0.ro5JMHEVuGOq2YsENkZigSpqMf5cmmgPP8odZfxrzJA $ curl -H \"Authorization: Bearer $TOKEN \" http://localhost:8000/user { \"user\" : \"test\" }","title":"Basic Usage"},{"location":"usage/freshness/","text":"The fresh tokens pattern is built into this extension. This pattern is very simple, you can choose to mark some access tokens as fresh and other as a non-fresh tokens, and use the paseto_required(fresh=True) function to only allows fresh tokens to access the certain endpoint. This is useful for allowing the fresh tokens to do some critical things (such as update user information), as you need to login using your user credentials again to get a fresh token.\\ Utilizing Fresh tokens in conjunction with refresh tokens can lead to a more secure site, without creating a bad user experience by making users constantly re-authenticate. Here is an example of how you could utilize refresh tokens with the fresh token pattern: from fastapi import FastAPI , HTTPException , Depends , Request from fastapi.responses import JSONResponse from fastapi_paseto_auth import AuthPASETO from fastapi_paseto_auth.exceptions import AuthPASETOException from pydantic import BaseModel app = FastAPI () class User ( BaseModel ): username : str password : str class Settings ( BaseModel ): authpaseto_secret_key : str = \"secret\" @AuthPASETO . load_config def get_config (): return Settings () @app . exception_handler ( AuthPASETOException ) def authpaseto_exception_handler ( request : Request , exc : AuthPASETOException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message }) # Standard login endpoint. Will return a fresh access token and a refresh token @app . post ( \"/login\" ) def login ( user : User , Authorize : AuthPASETO = Depends ()): if user . username != \"test\" or user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) \"\"\" create_access_token supports an optional 'fresh' argument, which marks the token as fresh or non-fresh accordingly. As we just verified their username and password, we are going to mark the token as fresh here. \"\"\" access_token = Authorize . create_access_token ( subject = user . username , fresh = True ) refresh_token = Authorize . create_refresh_token ( subject = user . username ) return { \"access_token\" : access_token , \"refresh_token\" : refresh_token } @app . post ( \"/refresh\" ) def refresh ( Authorize : AuthPASETO = Depends ()): \"\"\" Refresh token endpoint. This will generate a new access token from the refresh token, but will mark that access token as non-fresh, as we do not actually verify a password in this endpoint. \"\"\" Authorize . paseto_required ( fresh = True ) current_user = Authorize . get_subject () new_access_token = Authorize . create_access_token ( subject = current_user , fresh = False ) return { \"access_token\" : new_access_token } @app . post ( \"/fresh-login\" ) def fresh_login ( user : User , Authorize : AuthPASETO = Depends ()): \"\"\" Fresh login endpoint. This is designed to be used if we need to make a fresh token for a user (by verifying they have the correct username and password). Unlike the standard login endpoint, this will only return a new access token, so that we don't keep generating new refresh tokens, which entirely defeats their point. \"\"\" if user . username != \"test\" or user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) new_access_token = Authorize . create_access_token ( subject = user . username , fresh = True ) return { \"access_token\" : new_access_token } # Any valid PASETO access token can access this endpoint @app . get ( \"/protected\" ) def protected ( Authorize : AuthPASETO = Depends ()): Authorize . paseto_required () current_user = Authorize . get_subject () return { \"user\" : current_user } # Only fresh PASETO access token can access this endpoint @app . get ( \"/protected-fresh\" ) def protected_fresh ( Authorize : AuthPASETO = Depends ()): Authorize . paseto_required ( fresh = True ) current_user = Authorize . get_subject () return { \"user\" : current_user }","title":"Freshness Tokens"},{"location":"usage/optional/","text":"In some cases you might want to use one endpoint and adjust it's behavior depending on if the request contains a valid token or not. In this situation you can use the optional argument of paseto_required() . This will allow the endpoint to be accessed regardless of if a PASETO is sent in the request or not.\\ If a PASETO gets tampered with or is expired an error will be returned instead of calling the endpoint. from fastapi import FastAPI , HTTPException , Depends , Request from fastapi.responses import JSONResponse from fastapi_paseto_auth import AuthPASETO from fastapi_paseto_auth.exceptions import AuthPASETOException from pydantic import BaseModel app = FastAPI () class User ( BaseModel ): username : str password : str class Settings ( BaseModel ): authpaseto_secret_key : str = \"secret\" @AuthPASETOException . load_config def get_config (): return Settings () @app . exception_handler ( AuthPASETOException ) def authpaseto_exception_handler ( request : Request , exc : AuthPASETOException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message }) @app . post ( \"/login\" ) def login ( user : User , Authorize : AuthPASETO = Depends ()): if user . username != \"test\" or user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) access_token = Authorize . create_access_token ( subject = user . username ) return { \"access_token\" : access_token } @app . get ( \"/partially-protected\" ) def partially_protected ( Authorize : AuthPASETO = Depends ()): Authorize . paseto_required ( optional = True ) # If no paseto is sent in the request, get_subject() will return None current_user = Authorize . get_subject () or \"anonymous\" return { \"user\" : current_user }","title":"Partially Protecting"},{"location":"usage/refresh/","text":"These are long-lived tokens which can be used to create a new access tokens once an old access token has expired. Refresh tokens cannot access an endpoint that is protected with paseto_required() , and access tokens cannot access an endpoint that is protected with paseto_required(refresh_token=True) . Access tokens are marked as fresh if they were generated from the user authenticating with their user credentials, rather than a refresh token. This increases the chance of the authenticating entity actually being the user, rather than an attacker that stole a refresh token. By utilizing refresh tokens we can reduce the damage that can be done if an access tokens is stolen. However, if an attacker gets ahold of a refresh token they can keep generating new access tokens and access protected endpoints as though they were that user. We can help combat this by using the fresh tokens pattern, discussed in the next section. For accessing /refresh endpoint remember to change the token you send in a request from an access_token to a refresh_token Authorization: Bearer <refresh_token> Here is an example of using access and refresh tokens: from fastapi import FastAPI , HTTPException , Depends , Request from fastapi.responses import JSONResponse from fastapi_paseto_auth import AuthPASETO from fastapi_paseto_auth.exceptions import AuthPASETOException from pydantic import BaseModel app = FastAPI () class User ( BaseModel ): username : str password : str class Settings ( BaseModel ): authpaseto_secret_key : str = \"secret\" @AuthPASETO . load_config def get_config (): return Settings () @app . exception_handler ( AuthPASETOException ) def authpaseto_exception_handler ( request : Request , exc : AuthPASETOException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message }) @app . post ( \"/login\" ) def login ( user : User , Authorize : AuthPASETO = Depends ()): if user . username != \"test\" or user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) # Use create_access_token() and create_refresh_token() to create our # access and refresh tokens access_token = Authorize . create_access_token ( subject = user . username ) refresh_token = Authorize . create_refresh_token ( subject = user . username ) return { \"access_token\" : access_token , \"refresh_token\" : refresh_token } @app . post ( \"/refresh\" ) def refresh ( Authorize : AuthPASETO = Depends ()): \"\"\" The paseto_required(refresh_token=True) function insures a valid refresh token is present in the request before running any code below that function. We can use the get_subject() function to get the subject of the refresh token, and use the create_access_token() function again to make a new access token \"\"\" Authorize . paseto_required ( refresh_token = True ) current_user = Authorize . get_subject () new_access_token = Authorize . create_access_token ( subject = current_user ) return { \"access_token\" : new_access_token } @app . get ( \"/protected\" ) def protected ( Authorize : AuthPASETO = Depends ()): Authorize . paseto_required () current_user = Authorize . get_subject () return { \"user\" : current_user }","title":"Refresh Tokens"},{"location":"usage/revoking/","text":"This will allow you to revoke a specific tokens so that it can no longer access your endpoints.\\ You will have to choose what tokens you want to check against the denylist. Denylist works by providing a callback function to this extension, using the token_in_denylist_loader() .\\ This method will be called whenever the specified tokens (access and/or refresh) is used to access a protected endpoint.\\ If the callback function says that the tokens is revoked, we will not allow the requester to continue, otherwise we will allow the requester to access the endpoint as normal. This can be utilized to invalidate token in multiple cases, e.g.: - A user logs out and their currently active tokens need to be invalidated - You detect a replay attack and the leaked tokens need to be blocked Identifying tokens happens via the UUID that gets generated for each token, saved in the token payload using the \"jti\" claim. Here is a basic example use tokens revoking: from typing import Dict from fastapi import FastAPI , HTTPException , Depends , Request from fastapi.responses import JSONResponse from fastapi_paseto_auth import AuthPASETO from fastapi_paseto_auth.exceptions import AuthPASETOException from pydantic import BaseModel app = FastAPI () class User ( BaseModel ): username : str password : str # set denylist enabled to True # you can set to check access or refresh token or even both of them class Settings ( BaseModel ): authpaseto_secret_key : str = \"secret\" authpaseto_denylist_enabled : bool = True authpaseto_denylist_token_checks : set = { \"access\" , \"refresh\" } @AuthPASETO . load_config def get_config (): return Settings () @app . exception_handler ( AuthPASETOException ) def authpaseto_exception_handler ( request : Request , exc : AuthPASETOException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message }) # A storage engine to save revoked tokens. in production, # you can use Redis for storage system denylist = set () # For this example, we are just checking if the tokens jti # (unique identifier) is in the denylist set. This could # be made more complex, for example storing the blocked token in Redis @AuthPASETO . token_in_denylist_loader def check_if_token_in_denylist ( token_payload : Dict ): jti = token_payload [ \"jti\" ] return jti in denylist @app . post ( \"/login\" ) def login ( user : User , Authorize : AuthPASETO = Depends ()): if user . username != \"test\" or user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) access_token = Authorize . create_access_token ( subject = user . username ) refresh_token = Authorize . create_refresh_token ( subject = user . username ) return { \"access_token\" : access_token , \"refresh_token\" : refresh_token } # Standard refresh endpoint. # A token whose identifier/jti was saved in the denylist will not # be able to access this endpoint @app . post ( \"/refresh\" ) def refresh ( Authorize : AuthPASETO = Depends ()): Authorize . paseto_required ( refresh_token = True ) current_user = Authorize . get_subject () new_access_token = Authorize . create_access_token ( subject = current_user ) return { \"access_token\" : new_access_token } # Endpoint for revoking the current users access token @app . delete ( \"/access-revoke\" ) def access_revoke ( Authorize : AuthPASETO = Depends ()): Authorize . paseto_required () jti = Authorize . get_token_payload ()[ \"jti\" ] denylist . add ( jti ) return { \"detail\" : \"Access token has been revoked\" } # Endpoint for revoking the current users refresh token @app . delete ( \"/refresh-revoke\" ) def refresh_revoke ( Authorize : AuthPASETO = Depends ()): Authorize . paseto_required ( refresh_token = True ) jti = Authorize . get_token_payload ()[ \"jti\" ] denylist . add ( jti ) return { \"detail\" : \"Refresh token has been revoke\" } # A token in denylist will not be able to access this any more @app . get ( \"/protected\" ) def protected ( Authorize : AuthPASETO = Depends ()): Authorize . paseto_required () current_user = Authorize . get_subject () return { \"user\" : current_user } In production, you will likely want to use either a database or in-memory store (such as Redis) to store your tokens.\\ Memory stores are great if you are wanting to revoke a tokens when the users log out and you can define timeout to your tokens in Redis, after the timeout has expired, the tokens will automatically be deleted. Before that make sure redis already installed on your local machine, You can use docker using this command docker run -d -p 6379:6379 redis Here example use Redis for revoking a tokens: from fastapi import FastAPI , HTTPException , Depends , Request from fastapi.responses import JSONResponse from fastapi_paseto_auth import AuthPASETO from fastapi_paseto_auth.exceptions import AuthPASETOException from pydantic import BaseModel from datetime import timedelta from redis import Redis app = FastAPI () class User ( BaseModel ): username : str password : str class Settings ( BaseModel ): authpaseto_secret_key : str = \"secret\" authpaseto_denylist_enabled : bool = True authpaseto_denylist_token_checks : set = { \"access\" , \"refresh\" } access_expires : int = timedelta ( minutes = 15 ) refresh_expires : int = timedelta ( days = 30 ) settings = Settings () @AuthPASETO . load_config def get_config (): return settings @app . exception_handler ( AuthPASETOException ) def authpaseto_exception_handler ( request : Request , exc : AuthPASETOException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message }) # Setup our redis connection for storing the denylist tokens redis_conn = Redis ( host = \"localhost\" , port = 6379 , db = 0 , decode_responses = True ) # Create our function to check if a token has been revoked. In this simple # case, we will just store the tokens jti (unique identifier) in redis. # This function will return the revoked status of a token. If a token exists # in redis, token has been revoked @AuthPASETO . token_in_denylist_loader def check_if_token_in_denylist ( decrypted_token ): jti = decrypted_token [ \"jti\" ] entry = redis_conn . get ( jti ) return entry @app . post ( \"/login\" ) def login ( user : User , Authorize : AuthPASETO = Depends ()): if user . username != \"test\" or user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) access_token = Authorize . create_access_token ( subject = user . username ) refresh_token = Authorize . create_refresh_token ( subject = user . username ) return { \"access_token\" : access_token , \"refresh_token\" : refresh_token } # Standard refresh endpoint. Token in denylist will not # be able to access this endpoint @app . post ( \"/refresh\" ) def refresh ( Authorize : AuthPASETO = Depends ()): Authorize . paseto_required ( refresh_token = True ) current_user = Authorize . get_subject () new_access_token = Authorize . create_access_token ( subject = current_user ) return { \"access_token\" : new_access_token } # Endpoint for revoking the current users access token @app . delete ( \"/access-revoke\" ) def access_revoke ( Authorize : AuthPASETO = Depends ()): Authorize . paseto_required () # Store the tokens in redis with the value true for revoked. # We can also set an expires time on these tokens in redis, # so they will get automatically removed after they expired. jti = Authorize . get_token_payload ()[ \"jti\" ] redis_conn . setex ( jti , settings . access_expires , \"true\" ) return { \"detail\" : \"Access token has been revoke\" } # Endpoint for revoking the current users refresh token @app . delete ( \"/refresh-revoke\" ) def refresh_revoke ( Authorize : AuthPASETO = Depends ()): Authorize . paseto_required ( refresh_token = True ) jti = Authorize . get_token_payload ()[ \"jti\" ] redis_conn . setex ( jti , settings . refresh_expires , \"true\" ) return { \"detail\" : \"Refresh token has been revoke\" } # A token in denylist will not be able to access this any more @app . get ( \"/protected\" ) def protected ( Authorize : AuthPASETO = Depends ()): Authorize . paseto_required () current_user = Authorize . get_subject () return { \"user\" : current_user }","title":"Revoking Tokens"}]}